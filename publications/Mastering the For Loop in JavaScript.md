# Ի՞նչ կլինի եթե for ցիկլի կառուցվածքային մասերից որևէ մեկը կամ մի քանիսը բաց թողենք: Նաև մանրամասն կդիտարկենք for ցիկլի աշխատանքային քայլերի հաջորդականությունը:

Նախ վերհիշենք, թե ինֆորմատիկայում ինչ են իրենցից ներկայացնում ցիկլերը և ինչ կառուցվածքային մասերից է բաղկացած `for` ցիկլը։ Ցիկլը բարձր մակարդակի ծրագրավորման լեզուներում օգտագործվող կոնստրուկցիայի տարատեսակ է, որն օգնում է հեշտ և արագ կազմակերպել մի կամ մի քանի հրահանգների բազմաթիվ անգամ կատարումը։ `for` ցիկլն առկա է հանրաճանաչ ծրագրավորման լեզուների մեծ մասում, և համարվում է ամենաշատ օգտագործվող ցիկլը։ Սինթաքսն ունի հետևյալ տեսքը՝

```js
for (սկիզբ; պայման; քայլ) {
  ("ցիկլի մարմին");
}
```

Ենթադրենք մեզ պետք է բրաուզերի պատուհանում _alert_ անել _0, 1 և 2_ թվերը։ Առանց ցիկլի օգտագործման մենք այն կգրեյինք հետևյալ կերպ՝

```js
alert(0);
alert(1);
alert(2);
```

Հիմա նույն բանն անենք for ցիկլի օգնությամբ՝

```js
for (let i = 0; i < 3; i++) {
  alert(i);
}
```

Երբ ցիկլը սկսում է աշխատանքը, սկզբում կատարվում է `let i = 0` արտահայտությունը, այսինքն մենք հայտարարում ենք _i_ անունով փոփոխական և նրան վերագրում ենք _0_ սկզբնական արժեքը։ Այս արտահայտությունը ցիկլի ողջ աշխատանքի ընթացքում կատարվում է ընդամենը մեկ անգամ։ Այսինքն սկզբում այս վերագրումը կատարվեց, ու վերջ, մենք կարող ենք այս արտահայտության մասին այլևս մոռանալ։

Հաջորդը կատարվում է պայմանի ստուգումը՝ մեր օրինակում `i < 3`: Մենք _i_ փոփոխականին վերագրել ենք _0_ արժեքը, հետևաբար պայմանի ստուգման արտահայտությունը կլինի _0 < 3_։ _0_-ն _3_-ից փոքր է, այսինքն արտահայտությունը ճիշտ է, և համեմատության օպերատորը՝ մեր պարագայում _<_-ի նշանը, վերադարձնում է _true_: Որպեսզի ցիկլը շարունակի աշխատանքը, պետք է պայմանի ստուգման արդյունքում միշտ վերադառնա _true_: Որ պահին այդ արտահայտությունը վերադարձրեց _false_, ցիկլի աշխատանքը նույն պահին կդադարի։ Մեր օրինակում պայմանի ստուգման արդյունքը _true_ էր, հետևաբար ցիկլը շարունակում է աշխատել, անցնենք առաջ։

Այստեղ ուշադրություն՝ հաջորդը ոչ թե կատարվում է քայլը, ինչպես շատերին թվում է ըստ գրելաձևի հերթականության, այլ ցիկլի մարմնում գտնվող հրահանգը։ Այսինքն մեր օրինակում՝ բրաուզերի պատուհանում կատարվում է `alert(0)`, քանի-որ _i_-արժեքը _0_ է։ Ստացվում է մենք սկզբում ստեղծեցինք _i_ փոփոխականը և վերագրեցինք նրան _0_ արժեքը, ապա պայմանի ստուգման արտահայտության մեջ ստուգեցինք թե արդյոք _i_-ն փոքր էր _3_-ից, ստացանք դրական պատասխան՝ _true_, և միանգամից մտանք ցիկլի մարմնի մեջ գրված հրահանգը կատարելու, այն է՝ _alert_ անել _i_ փոփոխականը, որը հիմա _0_ է։ _alert_-ը կատարվեց, անցնենք առաջ։

Հաջորդը նոր կատարվում է քայլը, որը մեր օրինակի մեջ `i++`-ն է։ Ինչպես գիտենք **++** օպերատորը կոչվում է **ինկրեմենտի օպերատոր**, և այն փոփոխականի արժեքը մեծացնում է _1_-ով։ Մեր փոփոխականի արժեքը այլևս նախնական վերագրված _0_-ն չէ, այլ դարձել է _1_։ Այս քայլով եզրափակվում է ցիկլի աշխատանքի մի շրջանը, այդ պատճառով այն երբեմն կոչվում է նաև _ԵԶՐԱՓԱԿԻՉ ԱՐՏԱՀԱՅՏՈՒԹՅՈՒՆ_։

Այս ամբողջ շրջանը՝ պայմանի ստուգում, ցիկլի մարմնում տրված հրահանգի կատարում, ապա եզրափակիչ արտահայտության (քայլի) մեջ փոփոխականի արժեքի փոփոխությունը, անվանում են **_իտերացիա_**։

Մեր ցիկլի աշխատանքը դեռևս չի ավարտվել, ավարտվել է իտերացիան, այսինքն աշխատանքի մի շրջանը, սակայն ցիկլը կարող է ունենալ բազմաթիվ իտերացիաներ։ Եզրափակիչ քայլից հետո, երբ փոփոխականը դարձավ _1_, նորից կատարվում է պայմանի ստուգում։ `1 < 3` արտահայտությունը ճիշտ է, համեմատության օպերատորը վերադարձնում է _true_, նորից գործողությունն անցնում է ցիկլի մարմին և _alert_ է արվում _1_-ը, քանի-որ _i_ փոփոխականն այժմ ունի _1_ արժեքը։ Ապա կատարվում է իտերացիայի եզրափակիչ քայլը՝ մեր օրինակում `i++`-ը, և i փոփոխականն այժմ էլ դառնում է _2_։ Ավարտվեց ցիկլի աշխատանքի երկրորդ շրջանը, կամ ինչպես ընդունված է ասել՝ իտերացիան։

Նորից կատարվում է պայմանի ստուգում՝ `2 < 3`, արտահայտությունը կրկին ճիշտ է, համեմատության օպերատորը վերադարձնում է _true_ և սկսվում է ցիկլի աշխատանքի երրորդ իտերացիան։ Գործողությունն անցնում է ցիկլի մարմնում գրված հրահանգի կատարմանը, _alert_ է արվում _2_, ապա իտերացիան եզրափակվում է _i_ փոփոխականի ինկրեմենտացիայով, և _i_-ի արժեքը _2_-ից դառնում է _3_, ու մեր երրորդ իտերացիան ավարտվում է։

Այժմ պարզ է, որ պետք է նորից կատարվի պայմանի ստուգում, որի արդյունքից կախված ցիկլում կսկսվի կամ չի սկսվի չորրորդ իտերացիան։ `3 < 3` արտահայտությունը սխալ է, հետևաբար համեմատության օպերատորն այս անգամ վերադարձնում է _false_: Ցիկլն անհապաղ դադարեցնում է իր աշխատանքը, և արդեն կարելի է ասել, որ մեր օրինակում ցիկլը կատարեց երեք իտերացիա։ Նշենք նաև, որ եթե ցիկլի մարմնում ընդամենը մի հրահանգ է տրված, ապա ձևավոր փակագծերը կարող ենք բաց թողնել։ Երկու և ավելի հրահանգի առկայության դեպքում ձևավոր փակագծերի բաց թողնելը կհանգեցնի սխալի։ Մեր օրինակում՝

```js
for (let i = 0; i < 3; i++) alert(i);
```

Ընտրությունն իհարկե ձերն է, սակայն ձևավոր փակագծերը շատերի կարծիքով բավականին լավացնում են կոդի ընթեռնելիությունը:

Իսկ ի՞նչ կլինի, եթե փորձենք բաց թողնել `for` ցիկլի կառուցվածքային մասերը։ Նշեմ, որ փակագծերի մեջ գտնվող բոլոր երեք արտահայտություններն էլ ոչ պարտադիր (օպցիոնալ) են։ Օրինակ բերեք մեր օրինակը գրենք, բաց թողնելով սկիզբը՝

```js
let i = 0;
for (; i < 3; i++) alert(i);
```

Այստեղ մենք փոփոխականը հայտարարեցինք և նրան արժեք վերագրեցինք ցիկլի մարմնից դուրս։ Օրինակը նույն ձև նորմալ աշխատում է, հետևաբար կարող ենք եզրակացնել, որ սկիզբը մենք կարող ենք բաց թողնել։ Այժմ փորձենք բաց թողնել նաև եզրափակիչ քայլը՝

```js
let i = 0;
for (; i < 3; ) alert(i++);
```

Այստեղ մենք եզրափակիչ քայլում կատարվող արտահայտությունն ուղղակի տեղափոխեցինք ցիկլի մարմին, և այն դարձավ `while (i < 3) alert(i++)` ցիկլի անալոգը։

Մենք կարող ենք բաց թողնել նաև պայմանը և ստանալ անվերջ ցիկլ, սակայն որպեսզի այն հնարավոր լինի ինչ-որ պահի ընդհատել, կարող ենք օգտվել `break` ցիկլի կառավարման հրահանգի օգնությունից՝

```js
let i = 0;
for (;;) {
  if (i === 3) break;
  alert(i++);
}
```

Վերջին տարբերակը՝ `for (;;) {ցիկլի մարմինը}` շատ հաճախ օգտագործվում է կառավարելի անվերջ ցիկլեր ստանալու համար։ Նաև որպես լրացում նշեմ, որ թեև ցիկլի վերոհիշյալ մասերը կարող ենք բաց թողնել, որովհետև դրանք ոչ պարտադիր են, սակայն այդ մասերն իրարից բաժանող կետ ստորակետերը ՊԱՐՏԱԴԻՐ է դնել, հակառակ դեպքում կստանանք սինթաքսի սխալ։
