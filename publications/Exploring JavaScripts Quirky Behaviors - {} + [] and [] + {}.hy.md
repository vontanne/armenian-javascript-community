# JavaScript-ի զվարճալի տարօրինակությունները շարքից՝ դատարկ օբյեկտին գումարած դատարկ զանգվածը հավասար է 0, բայց դատարկ զանգվածին գումարած դատարկ օբյեկտը՝ "[object Object]": Այնուամենայնիվ՝ {} + [] === [] + {} արտահայտությունը վերադարձնում է true: Ինչու՞ տեղափոխական հատկությունը (Commutative property) մի դեպքում չի գործում, իսկ մյուս դեպքում անխափան աշխատում է:

Գումարման կանոնները **JavaScript**-ում շատ պարզ են։ Մենք կարող ենք իրար գումարել միայն թվեր և համակցել տողեր (_Number, BigInt և String տվյալների տիպեր_): Բոլոր մնացած տիպերին պատկանող արժեքների գումարման դեպքում այդ արժեքներն անուղղակի փոխակերպվում են կամ _Number_, կամ _String_ տիպի, եթե այդ փոխակերպումը հնարավոր չէ, ապա ստանում ենք տիպերի վերափոխման հետ կապված սխալ՝ _TypeError_։ Այս բոլոր կանոնները մանրամասն նկարագրված են լեզվի ստանդարտում՝ **ECMA-262-ում**։ Այժմ տեսնենք թե ինչ տրամաբանությամբ են կատարվում այդ անուղղակի փոխակերպումները՝ դատարկ օբյեկտի և դատարկ զանգվածի գումարման ժամանակ, և ինչու՞ մի դեպքում գումարման տեղափոխական հատկությունը չի գործում, իսկ մյուս դեպքում այն նորմալ աշխատում է։

Նախ _{} + []_ արտահայտության մասին։ Բրաուզերներում ներդրված ինտերպրետատորն արտահայտության ձախ մասում գտնվող դատարկ օբյեկտն ընդունում է որպես կոդի բլոկ։ Եվ քանի-որ ձևավոր փակագծերի մեջ գտնվող բլոկը դատարկ է, ինտերպրետատորն ուղղակի անտեսում է այն, և անցնելով առաջ՝ զանգվածի առջևում դրված + օպերատորն արդեն ընկալում է որպես ունար պլյուս։ Ստացվում է, որ _{} + []_ արտահայտությունն ինտերպրետատորը տեսնում է որպես ինչ-որ դատարկ կոդի բլոկ, որը պետք է անտեսվի, և դատարկ զանգված, որի առջև դրված է ունար պլյուս։ Ինչպես գիտենք ունար պլյուսի օպերատորը ցանկացած տիպի պատկանող արժեք փորձում է վերածել թվային տիպի, այն կարելի է ասել ցանկացած տիպի վրա կանչում է _Number()_ ֆունկցիան, և շատ հաճախ հենց այդ նպատակով էլ օգտագործվում է, որպես _Number()_ ֆունկցիայի կանչի կարճ գրելաձև։

```js
+[] === 0; // true
```

_+[]_ արտահայտությունն ամբողջովին համարժեք է _Number([])_ արտահայտությանը և ընդամենը հանդիսանում է համառոտ գրելաձև՝ օգնելով կրճատել գրվող կոդի ծավալը։

Հաջորդ արտահայտությունը՝ _[] + {}_, ինտերպրետատորի կողմից այլ կերպ է դիտարկվում։ Պլյուս օպերատորն այստեղ ընկալվում է որպես համակցման օպերատոր, հետևաբար դատարկ զանգվածը վերածվում է դատարկ տողի, քանի-որ ինչպես գիտենք լեզվի՝ տիպերի անուղղակի վերափոխման կանոններով այդպես է նախատեսված։ Տակից դատարկ զանգվածի վրա կանչվում է ներդրված _toString_ մեթոդը։

```js
[].toString(); // ""
```

Դատարկ օբյեկտի վրա նույնպես տակից կատարվում է _toString_ մեթոդի կանչը՝ ըստ ստանդարտում նկարագրված օբյեկտից _String_ տիպին անուղղակի վերափոխման կանոնների։ Այդպես լինում է օրինակ, երբ մենք փորձում ենք որևէ օբյեկտ _alert_ անել։ Քանի-որ _alert_ ֆունկցիան աշխատում է միայն _String_ տիպի հետ՝ ցանկացած այլ տիպ անուղղակի վերափոխում է _String_-ի։ Օբյեկտների դեպքում, երբ **Symbol.toPrimitive** կամ **toString** մեթոդների օգնությամբ ուղղակի տրված չի լինում, թե այդ փոխակերպումներն ինչ տրամաբանությամբ կատարվեն, անուղղակի փոխակերպման արդյունքը միշտ լինում է **"[object Object]"**։

```js
({}).toString(); // "[object Object]"
```

Հետևաբար _[] + {}_ արտահայտության մեջ մենք իրար ենք համակցում (_concat_) դատարկ տողն ու _"[object Object]"_ տողը՝ արդյունքում ստացվում է _"[object Object]"_։

Այժմ դիտարկենք _{} + [] === [] + {}_ հավասարությունը, որը վերադարձնում է _true_, թեև առանձին առանձին հավասարության ձախ և աջ կողմերը տարբեր արժեքներ են վերադարձնում։

Այստեղ արդեն ինտերպրետատորը _{} + []_ արտահայտության մեջ _{}_-ը դիտարկում է ոչ թե որպես կոդի դատարկ բլոկ, այլ որպես դատարկ օբյեկտ, և պլյուս օպերատորն ընդունելով, որպես համակցման օպերատոր, օբյեկտը անուղղակի վերափոխում է _String_ տիպին, ստանալով _"[object Object]"_, ապա նրան համակցում է դատարկ զանգվածի վերափոխումից ստացված դատարկ տողը։ Այսինքն հավասարության ստուգման ժամանակ ձախ և աջ ենթաարտահայտությունները ենթարկվում են լրիվ նույն տրամաբանությամբ փոխակերպման, և դրա համար էլ նույնականության օպերատորը վերադարձնում է _true_:

Ինտերպրետատորը կարծես _{} + []_ արտահայտությունը տակից խմբավորում է փակագծերի մեջ, որը և թույլ է տալիս ստանալ նման արդյունք։ Համեմատենք՝

```python
{} + [] // 0
({} + []) // "[object Object]"
```

Չնայած միջավայրերի մեծ մասում մենք կունենանք նկարագրված արդյունքը՝ չի բացառվում, որ լինեն ոչ այնքան հայտնի բրաուզերներ որոնք վերադարձնեն բոլորովին այլ արդյունք: Այլ «տարօրինակություններ» կարող եք տեսնել [այս](https://wtfjs.com/) կայքում։
