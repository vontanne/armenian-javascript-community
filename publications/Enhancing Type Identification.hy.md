# Ստեղծենք ՖՈՒՆԿՑԻԱ, որը շատ ավելի ճշգրիտ է աշխատում և անհամեմատ օգտակար է, քան typeof օպերատորը

**typeof** օպերատորի միջոցով տվյալների տիպը որոշելու ժամանակ բոլոր օբյեկտային _(հղումային)_ տիպերի համար վերադարձվում է **"object"**, լինի դա սովորական _օբյեկտ_, _զանգված_, _Map_ թե _Set_. Մեր ստեղծած Ֆունկցիան պետք է ճշգրիտ ցույց տա թե օբյեկտային տիպի կոնկրետ ո՞ր դասին են պատկանում տվյալները և կարողանա տարբերել օրինակ _զանգվածը_՝ _Map_-ից

Ինչպես գիտենք **ECMAScript 2023** կամ համառոտ՝ **ES14** ստանդարտով JavaScript-ում կան _7_ պրիմիտիվ և _մեկ_ օբյեկտային _(reference type)_ տվյալների տեսակներ։(Իրականում ամեն ինչ մի փոքր այլ է, և JS-ում չկան պրիմիտիվ տիպեր այն իմաստով, ինչ մի շարք այլ ծրագրավորման լեզուներում է, և մի շարք այսպես կոչված «պրիմիտիվ» տիպեր JS-ում հանդիսանում են ուղղակի անփոփոխելի օբյեկտներ, բայց դա արդեն այլ ծավալուն թեմա է)։ Օբյեկտային տիպը իր հերթին բաժանվում է մի քանի դասերի։ Օրինակ թե՛ _Array_-ը, թե՛ _Function_-ը, թե՛ _Map_-ն ու _Set_-ը համարվում են օբյեկտներ։ Երբ մենք տվյալների տիպը որոշելու համար օգտագործում ենք **typeof** օպերատորը, այն երբեմն իրոք հարմար չէ, որովհետև նա մեզ ինֆորմացիա չի տալիս, թե կոնկրետ ինչ դասի օբյեկտ է ստուգվողը։ Բացի դրանից **typeof** օպերատորը _Null_ տիպը ստուգելուց վերադարձնում է _"object"_, ինչը նույնպես կարող է թյուրիմացությունների պատճառ դառնալ։

Այժմ փորձենք ստեղծել ֆունկցիա, որը չի ունենա **typeof** օպերատորի թերությունները, և օգտակար կլինի լայն սպեկտրով խնդիրների լուծման համար։

Տարբեր արժեքների վրա Օբյեկտի նախատիպի _(Object.prototype) toString_ մեթոդի կանչը վերադարձնում է տարբեր արդյունքներ։ Օրինակ՝

```js
Object.prototype.toString.call("hello"); // "[object String]"
Object.prototype.toString.call(888); // "[object Number]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call(/abc/); // "[object RegExp]"
Object.prototype.toString.call(new Date()); // "[object Date]"
```

Այսպիսով ինչպես տեսնում ենք մեթոդը միշտ վերադարձնում է սթրինգ, որի առաջին բառը դա _object_-ն է, իսկ երկրորդը թե այն ինչ դասի է պատկանում։ Փաստորեն եթե մենք օգտագործենք _regular expression_ կամ սթրինգի _slice_ մեթոդը, կարող ենք կտրել վերադարձվող արժեքի մեզ ոչ անհրաժեշտ մասերը, և ստանալ թե կոնկրետ ինչ դասի է պատկանում արժեքը, որը մենք ստուգում ենք։ Ես կօգտագործեմ _slice_ մեթոդը։ Եվ այսպիսով ֆունկցիայի վերջնական տեսքը կլինի՝

```js
function toRawType(value) {
  const _toString = Object.prototype.toString;
  const str = _toString.call(value);
  return str.slice(8, -1);
}
```

Կարող ենք ևս մի քիչ կրճատել կոդի ծավալը՝ օգտագործելով _arrow function_: Կարծում եմ այն շարունակում է մնալ նույնքան հասկանալի, որքան վերևի օրինակը։

```js
const toRawType = (value) => Object.prototype.toString.call(value).slice(8, -1);
```

Իսկ հիմա փորձենք աշխատացնել ֆունկցիան․

```js
toRawType([1, 2, 3]); // "Array"
toRawType({ color: "red" }); // "Object"
toRawType(123); // "Number"
toRawType("Hello, World!"); // "String"
toRawType(true); // "Boolean"
toRawType(function () {}); // "Function"
toRawType(null); // "Null"
toRawType(undefined); // "Undefined"
```
