# JavaScript-ի զվարճալի տարօրինակությունները։ Մաս 3

Այսօր մենք կանդրադառնանք **JavaScript**-ի ևս մի զվարճալի տարօրինակության, որը սակայն ավելի խորությամբ նայելու դեպքում կհասկանանք, որ այն լրիվ հասկանալի և կանխատեսելի վարքագիծ է։ Եվ այսպես, եթե կոնսոլում փորձենք արտածել հետևյալ արտահայտության արժեքը՝

```js
console.log(parseInt(null, 24));
```

ապա կստանանք 23, ինչն առաջին հայացքից այնքան էլ հասկանալի չէ, ինչու՞ և ո՞րտեղից։ Հասկանալու համար բերեք ավելի մանրամասն դիտարկենք parsInt ֆունկցիայի աշխատանքը։ **MDN**-ում նկարագրված է `parsInt` ֆունկցիան, որտեղ ասվում է, որ այն որպես առաջին արգումենտ ստանում է _string_, և վերադարձնում է թիվ, համապատասխան այն հաշվարկման համակարգի, որը մենք տալիս ենք որպես երկրորդ արգումենտ։ Ահա սինթաքսը՝

`parseInt(string, radix)`;

- string - արժեքն է, որն անհրաժեշտ է ինտերպրետացնել։ Եթե այս պարամետրի արժեքը չի պատկանում String տիպի, ապա այն անուղղակիորեն վերափոխվում է այդ տիպին, toString մեթոդի կանչի արդյունքում։ Տողի սկզբի բացատները հաշվի չեն առնվում։

- radix - ամբողջ թիվ է, _2-ից 36 միջակայքում_, և մատնանշում է, թե հաշվարկման որ համակարգն ենք օգտագործում։ Օրինակ _2_-ը դա երկուական կամ բինար համակարգն է, _8_-ը՝ ութականը, _16_-ը՝ տասնվեցականը։ Քանի որ մեծամասամբ մենք օգտագործում ենք հաշվարկման տասական համակարգը, ապա այն հանդիսանում է որպես սկզբնական (default) արժեք։ Այնուամենայնիվ խորհուրդ է տրվում միշտ նշել, թե որ համակարգն եք օգտագործում, որպեսզի ֆունկցիայի աշխատանքը երաշխավորված կոռեկտ լինի։

`parsInt` ֆունկցիան փորձում է սիմվոլ առ սիմվոլ առաջին արգումենտից կարդալ, առանձնացել թվերը։ Երբ նա հանդիպում է սիմվոլի, որը նշված հաշվարկման համակարգում իրենից թիվ չի ներկայացնում, ապա վերադարձնում է մինչ այդ սիմվոլը առանձնացրած թվերը։

Եթե հենց առաջին իսկ սիմվոլը չի հանդիսանում թիվ, ապա ֆունկցիան վերադարձնում է _NaN_: Օրինակ՝

- `parseInt("F", 16)` - (վերադարձնում է 15, քանի որ 16-ական հաշվարկման համակարգում(0 - 9 և A-F), F սիմվոլը համապատասխանում է տասական համակարգի 15 թվին)։

- `parseInt("17", 8)` - (վերադարձնում է 15, քանի որ 8-ական հաշվարկման համակարգում (0 - 7) այն համապատասխանում է տասական համակարգի 15 թվին)։

- `parseInt("1111", 2)` - (կրկին 15 է վերադարձնում, որովհետև որպես երկրորդ արգումենտ մենք նշել ենք հաշվարկման երկուական համակարգը, իսկ այդ համակարգում 1111-ը դա տասական համակարգի 15-ն է)։

- `parseInt(15.99, 10)` - (վերադարձնում է 15, ֆունկցիան թվի մնացորդով մասը դեն է նետում)։

- `parseInt("H75", 10)` - (վերադարձնում է _NaN_, որովհետև տասական համակարգում _H_-ը իրենից թվային սիմվոլ չի ներկայացնում, իսկ եթե առաջին սիմվոլը թիվ չէ, ապա ֆունկցիան աշխատանքը անհապաղ դադարեցնում է և վերադարձնում է _NaN_):

- `parseInt("546", 2)` - (կրկին _NaN_ է վերադարձնում, երկուական համակարգում _5_ թվային սիմվոլ գոյություն չունի, և հենց առաջին քայլից ֆունկցիան դադարեցնում է աշխատանքը)։

Հիմա արդեն, երբ մանրամասն ծանոթացանք parsInt ֆունկցիայի աշխատանքի հետ, բերեք հասկանանք մեր օրինակի տրամաբանությունը։ Սկսենք նրանից, որ մենք որպես առաջին արգումենտ, ֆունկցիային տվել ենք `null` արժեքը, իսկ վերևում արդեն նշել եմ, որ `parsInt`-ը որպես առաջին արգումենտ ընդունում է միայն `String` տիպին պատկանող արժեքներ, իսկ այլ արժեքների դեպքում կատարվում է անուղղակի վերափոխում և արդյունքում այն այնուամենայնիվ վերածվում է String տիպի։ Ահա թե ինչ է կատարվում․

```js
parseInt(null, 24) === parseInt("null", 24);
```

Հաջորդը հասկանանք թե ինչ է իրենից ներկայացնում որպես երկրորդ արգումենտ (radix) հաղորդած _24_ թիվը։ Այն նշանակում է, որ մենք ուզում ենք ֆունկցիան իր գործառույթը իրականացնի,որպես հաշվարկի հիմք ընդունելով _24_-ական համակարգը։ Իսկ _24_-ական համակարգը դա _0 - 9_ թվերի և անգլերենի այբուբենի _A-ից մինչև N_ թվերի համախումբն է։ Օրինակ _24_-ական համակարգի _"LM"_ թիվը դա տասական համակարգի _526_ թիվն է։

`parsInt` ֆունկցիան սկսում է _24_-ական համակարգի վրա հենվելով հերթով ստուգել _"null"_ տողի սիմվոլները, թվային համապատասխանություններ գտնելու համար։ Առաջին սիմվոլը՝ _"n"_-ն,համապատասխանում է տասական համակարգի _23_ թվին։ Հաջորդ սիմվոլը՝ _"u"_-ն, _24_-ական հաշվարկի համակարգում ոչ մի թվի չի համապատասխանում, հետևաբար ֆունկցիան դադարեցնում է աշխատանքը, և վերադարձնում է _"n"_-ի տասական արժեքը՝ _23_ թիվը։

Այսպիսի _«տարօրինակություններ»_ **JavaScript**-ում շատ կան։ Բայց իրականում դրանք տարօրինակություններ չեն, այլ կուռ հիմնավորված, համակարգված լեզվական առանձնահատկություններ են, որոնք անհրաժեշտ է հասկանալ։ Իսկ խորությամբ հասկանալով ավելի շատ կսիրեք այս իրոք յուրօրինակ ու զարմանահրաշ ծրագրավորման լեզուն։
