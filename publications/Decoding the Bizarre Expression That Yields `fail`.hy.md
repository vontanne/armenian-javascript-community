# JavaScript-ի զվարճալի տարօրինակությունները։ Մաս 2

Եթե մենք բրաուզերի կոնսոլում հավաքենք հետևյալ արտահայտությունը՝

```js
(![] + [])[+[]] +
  (![] + [])[+!+[]] +
  ([![]] + [][[]])[+!+[] + [+[]]] +
  (![] + [])[!+[] + !+[]];
```

ապա այն կվերադարձնի **"fail"** բառը: Առաջին հայացքից կարող է անհասկանալի թվալ թե ինչպես է հնարավոր նման կամայական սիմվոլների հերթականությամբ, որոնցից ոչ մեկը տառ չէ, բառ ստանալ:

Այժմ փորձենք քայլ առ քայլ նայել արտահայտությունը, և պարզ կդառնա, որ այն ուղղակի սիմվոլների կամայական հերթականություն չէ, և լեզվի կանոնների համաձայն տեղի ունեցող` ներդրված մեթոդների անուղղակի կանչերի կամ օպերատորների օգտագործման արդյունքում մենք ստանում ենք շատ հետաքրքիր կոմբինացիաներ, և գործնականում կարող ենք ստանալ անգլերենի այբուբենի բոլոր տառերը։ Արտահայտությանը նայելիս առաջինը աչքի է զարնում այն, որ շատ հաճախ կրկնվում է _(![]+[])_ ենթաարտահայտությունը։ Տրամաբանական և մաթեմատիկական օպերատորների օգտագործման անուղղակի փոխակերպումների արդյունքում ինտերպրետատորը այն վերածում է _String_ տիպի, նրա վրա կանչելով _toString()_ մեթոդը։

_(![]+[])․toString()_ -ը վերադարձնում է "false" սթրինգը, և այժմ եթե մենք նույն սիմվոլների օգնությամբ կարողանանք ստանալ 0-ից մինչև 4 թվերը, քառակուսի փակագծերի միջոցով դիմելով այդ սթրինգին, առանձին առանձին կստանանք _"f", "a", "l", "s", "e"_ տառերը, որոնք էլ տարբեր կոմբինացիաներով կարող ենք օգտագործել բառեր կազմելու համար։

Մենք գիտենք որ _"false"[0]_-ն դա _"f"_ տառն է, _"false"[1]_-ը՝ _"a"_-ն, _"false"[2]_-ը _"l"_-ը և այդպես շարունակ։ Եվ այսպես _+[]_ ենթաարտահայտությունը վերադարձնում է _0_, քանի-որ դատարկ զանգվածի դիմաց դնելով ունար պլյուսի օպերատորը, մենք անուղղակիորեն այն վերածում ենք թվային տիպի _(Number)_: Ինտերպրետատորը այդ փոխակերպումը կատարում է ենթաարտահայտության վրա տակից աշխատացնելով _valueOf_ մեթոդը, այն իրականում լինում է այսպես՝ _(+[]).valueOf()_ -> _0_: Այսպիսով _(![]+[])[+[]]_ ենթաարտահայտությունը համարժեք է _"false"[0]_-ին, և մենք արդեն ունենք _"f"_ տառը։

Հաջորդը՝ _+!+[]_ ենթաարտահայտությունը էլի ներդրված մեթոդների կանչի արդյունքում անուղղակիորեն վերածվում է _1_-ի։ Եվ դիմելով _(![]+[])[+!+[]]_-ին, մենք ստանում ենք _"false"_ բառի երկրորդ տառը՝ _"a"_-ն։

_"l"_ տառի հետ նույնպես ամեն ինչ պարզ է, _!+[]+!+[]_ ենթաարտահայտությունը անուղղակի փոխակերպվում է _2_-ի և դիմելով _(![]+[])_-ին, մենք այնտեղից դուրս ենք բերում _"false"_ բառի երկրորդ ինդեքսում գտնվող _"l"_ տառը։

_"i"_ տառը ստանալ մի քիչ ավելի դժվար է, քանի որ _"false"_ բառի մեջ այդ տառը բացակայում է։ Բայց ինչպես գիտենք մեր սիրելի լեզվում ոչ մի անհնար բան գոյություն չունի, և համադրելով սիմվոլներն այս հերթականությամբ՝ _([![]]+[][]])_, մենք անուղղակի փոխակերպման արդյունքում (ինտերպրետատորը տակից էլի աշխատեցնում է _([![]]+[][]]).toString()_ մեթոդը) ստանում ենք _"falseundefined"_։

Այժմ մեզ անհրաժեշտ է ստանալ _10_ թիվը, որպեսզի _"falseundefined"_ բառից կարողանանք դուրս հանել _10_-րդ ինդեքսում գտնվող _"i"_ տառը։ Իսկ դա անելը շատ հեշտ է արդեն, _+!+[]+[+[]]_ ենթաարտահայտությունը տակից աշխատող _valueOf()_ ներդրված մեթոդի շնորհիվ վերադարձնում է _10_ թիվը։ Համադրելով _([![]]+[][]])[+!+[]+[+[]]]_ վերը ստացված երկու ենթաարտահայտությունները, մենք դուրս ենք բերում նաև _"i"_ տառը։ Այսպիսով ստացվում է ՝

```js
(![]+[])[+[]] + // "f"
(![]+[])[+!+[]] + // "a"
([![]]+[][]])[+!+[]+[+[]]] + // "i"
(![]+[])[!+[]+!+[]] // "l"

"f" + "a" + "i" + "l" - "fail"
```

Կարող եք փորձել ստանալ անգլերենի այբուբենի բոլոր տառերը, և կազմել տարբեր բառեր, ասենք ձեր անունը։ Սա լեզվական առանձնահատկություն է, որը պայմանավորված է **JavaScript** լեզվի թույլ տիպաբանությամբ, երբ տարբեր օպերատորներ օգտագործելով կարողանում եք մի շարք ոչ ակնհայտ, անուղղակի փոխակերպումներ կատարել մի տիպից մյուս տիպ։

Ուրիշ «տարօրինակությունների» ծանոթանալու համար կարող եք այցելել [այս](https://wtfjs.com/) հղումով։
