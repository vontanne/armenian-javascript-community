# Ինչ տարբերություններ կան BigInt և Number տվյալների տիպերի միջև: Number տիպի ո՞ր թերությունները ստիպեցին JavaScript ծրագրավորման լեզվում ավելացնել նոր տվյալների տիպը՝ BigInt-ը:

**BigInt**-ը համեմատաբար նոր թվային պրիմիտիվ տիպ է **JavaScript**-ում, որը թույլ է տալիս աշխատել կամայական մեծության ամբողջ թվերի հետ։ **BigInt**-ի շնորհիվ մենք կարող ենք անվտանգ պահպանել և մշակել ամբողջ թվային տվյալներ, որոնք դուրս են **Number** թվային տիպի արժեքների թույլատրելի միջակայքից։

Հիշեցնեմ, որ **Number** թվային տիպը հիշողության մեջ պահպանվում է **64** բիթ **IEEE-754** ֆորմատով, որը նաև անվանում են _double precision floating point numbers_. Այդ ֆորմատը ենթադրում է որ **52** բիթ տրամադրվում է թվի պահպանման, **11** բիթ՝ ոչ ամբողջ մասի կետի դիրքի (եթե ամբողջ թիվ է, ապա այնտեղ 0 է), և **1** բիթը տրամադրվում է նշանի պահպանման համար (_բացասական կամ դրական, այստեղից էլ առաջանում է -0-ի հետ կապված կազուսը_): Այս ֆորմատը մեծամասամբ բավարարում է առօրյա անհրաժեշտ խնդիրների մեծ մասի լուծմանը, և բավականին հարմար ֆորմատ է։

Սակայն այն ունի նաև մի շարք թերություններ։ Միջակայքը, որում կարելի է ճշգրիտ ու անվտանգ թվաբանական գործողություններ անել, սահմանափակվում է -(2^53 - 1)-ից մինչև 2^53 - 1։ Այս ֆորմատի յուրահատկությունը նաև այն է, որ առաջանում է 2 տեսակի զրո, դրական և բացասական(_0 և -0_),ինչը մաթեմատիկայի տեսանկյունից անհեթեթություն է։ Եվ թեև ինտերպրետատորն այդ երկու զրոները մեծամասամբ ընդունում է որպես նույնական, այնուամենայնիվ որոշ դեպքերում կարող են անհարմարություններ առաջանալ։

**_BigInt_**-ը հնարավորություն է տալիս օգտագործել շատ մեծ ամբողջ թվեր և բարձր ճշգրտության թվաբանական գործողություններ կատարել նրանց հետ։ Որպեսզի ստեղծենք BigInt, անհրաժեշտ է ընդամենը թվային լիտերալի վերջում ավելացնել n տառը։ Օրինակ՝

```js
const sameValue = 42n;
```

Կարելի է նաև կանչել **BigInt** ֆունկցիան և նրան որպես արգումենտ տալ ցանկացած սովորական թիվ, որը կարող է լինել ինչպես **Number**, այնպես էլ **String** տիպի։ Օրինակ՝

```js
const bigintValue = BigInt(4521451);
const anotherValue = BigInt("2564879");
```

Թվաբանական գործողությունների ժամանակ **BigInt**-ը կարելի է օգտագործել որպես սովորական թիվ։ **BigInt**-ով կատարվելիք գործողությունը վերադարձնում է միայն **BigInt**: Միաժամանակ միևնույն հաշվարկի մեջ օգտագործել թե՛ **BigInt** և թե՛ **Number** չի թույլատրվում։ Օրինակ՝

```js
console.log(2n + 3n); // 5n
console.log(2n + 3); // Uncaught TypeError
```

Եթե որևէ թվաբանական գործողության արդյունքում ակնկալվում է ոչ ամբողջ թիվ, ապա գործողության արդյունքից ոչ ամբողջ մասը դեն է նետվում։ **BigInt**-ը կարող է լինել միայն ամբողջ թիվ, ինչն անվանումից էլ արդեն պարզ է (_big integer_): Օրինակ՝

```js
console.log(5n / 2n); // 2n
```

Քանի որ **BigInt**-ն առանձին տիպ է, **Number** կամ թվային արժեք պարունակող **String** տիպի հետ խիստ հավասարության ստուգման դեպքում, երբ տիպերի փոխակերպում չի կատարվում` համեմատությունը միշտ կլինի _false_: Օրինակ՝

```js
console.log(25 === 25n); // false
console.log("25" === 25n); // false
```

Ոչ խիստ հավասարության ստուգման դեպքում կկատարվի տիպերի անուղղակի փոխակերպում, ինչի արդյունքում կունենանք վերևի օրինակից տարբերվող արդյունք՝

```js
console.log(25 == 25n); // true
console.log("25" == 25n); // true
```

Երբ **BigInt** թվային արժեքը ուղղակիորեն փոխակերպվում է բուլյան տիպի, այդ փոխակերպումը ոչ մի բանով չի տարբերվում **Number** տիպի համապատասխան արժեքի փոխակերպումից։
Օրինակ բոլոր այս դեպքերում՝ if, while, for, &&, || , Boolean ֆունկցիա.

```js
if (0n) {
  console.log("if");
} else {
  console.log("else");
} // կտպի else, քանի որ 0n-ը falsy արժեք է։

0n && 5; // 0n, առաջին falsy արժեքն է։
0n || 8n; // 8n, առաջին truty արժեքն է։
```

Հիմնական օպերատորների մեծ մասը **BigInt**-ի հետ կարելի է կիրառել, օրինակ բինար + - / \* \*\* %։ Բիթային օպերացիաների օպերատորները նույնպես կարող են հաջողությամբ կիրառվել( | & << >> և ^ )։ Ունար մինուսը կարող է կիրառվել բացասական **BigInt** սահմանելու համար (_օրինակ՝ -8n_), սակայն ունար պլյուսը չի կարող օգտագործվել և օգտագործելու պարագայում կունենանք _TypeError_:

Եզրափակելով կարելի է ասել, որ առօրյա խնդիրների ճնշող մեծամասնության մեջ մենք դժվար թե առիթ ունենանք կիրառել **BigInt**, քանի որ **Number** տիպը հիանալիորեն կարողանում է լուծել **JavaScript** ծրագրավորողի առջև դրված խնդիրների մեծ մասը։ Բայց որոշ սպեցիֆիկ դեպքերում, երբ անհրաժեշտ է գործ ունենալ շատ մեծ ամբողջ թվերի հետ, կոդում մենք կարող եք հանդիպել **BigInt**-ի կիրառությանը։ Նաև պետք է հաշվի առնել, որ այն ներդրվել է ստանդարտ համեմատաբար վերջերս, և շատ բրաուզերներ կարող են այն չսպասարկել։

Ներքևի հղումներով կարող եք ծանոթանալ տվյալների այս նոր տիպի սպեցիֆիկացիային և նաև տեսնել, թե որ բրաուզերների ինչ տարբերակներ են սպասարկում այն։

[BigInt Specification](https://tc39.es/ecma262/#sec-bigint-objects)  
[BigInt Browser Support](https://caniuse.com/bigint)
