# for in ցիկլի աշխատանքի առանձնահատկությունները: Ինչու՞ ցանկալի չէ այս ցիկլն օգտագործել զանգվածների իտերացիայի համար: Օբյեկտների մակերեսային պատճենումը for in ցիկլի օգնությամբ:

Ինչպես գիտենք **for in** ցիկլն օգտագործվում է օբյեկտների իտերացիայի համար։ Սակայն այստեղ գոյություն ունեն մի շարք նրբություններ, որոնք անհրաժեշտ է իմանալ՝ ցիկլը ճիշտ օգտագործելու համար։ Ցիկլն ունի հետևյալ ընդհանրական տեսքը՝

```js
for (let key in object) {
  // Ցիկլի մարմինը
}
```

Ցիկլն աշխատում է հետևյալ կերպ՝

- Սկզբից հայտարարվում է _key_ փոփոխականը, որին հերթով վերագրվում է _object_ անունով օբյեկտի բոլոր հատկությունների անունները (կամ ինչպես երբեմն ասում են՝ բանալիները)։ Փոփոխականին բնականաբար կարելի է տալ ցանկացած անուն, սակայն ինչպես ընդունված է սովորական _for_ ցիկլի մեջ փոփոխականներն անվանել _i, j կամ k,_ այնպես էլ _for in_ ցիկլի մեջ փոփոխականին հիմնականում տրվում են _key, prop կամ attribute_ անվանումները։

- Ապա ցիկլը սկսում է արտածել օբյեկտի բոլոր թվարկելի հատկությունները։ Պետք է նշել, որ օբյեկտների մեջ կարող են լինել հատկություններ, որոնք թվարկելի չեն, և _for in_ ցիկլը նրանց «չի նկատում»։ Դրանք այն հատկություններն են, որոնց ստեղծման ժամանակ _enumerable_ ֆլագը նշված է որպես _false_: Նաև ինչպես գիտենք՝ սկսած **ES6** ստանդարտից՝ օբյեկտների հատկությունների անունները կարող են լինել ոչ միայն _String_, այլ նաև _Symbol_ տիպի։ _for in_ ցիկլին հասանելի են միայն հատկությունների _String_ տիպին պատկանող անունները, այն չի «տեսնում» հատկությունները, որոնց բանալին _Symbol_ տիպի է։

- Ցիկլի մարմնի մեջ գրված հրահանգը կատարվում է օբյեկտի յուրաքանչյուր հատկության համար։

- Երբ օբյեկտի բոլոր թվարկելի հատկություններին արդեն հասանելիությունն ապահովված է, և ցիկլի մարմնում գրված հրահանգը յուրաքանչյուր հատկության համար կատարված՝ ցիկլն ընդհատում է աշխատանքը։

- Ցիկլը հասանելիություն ունի նաև օբյեկտի պրոտոտիպերից ժառանգված բոլոր թվարկելի հատկություններին։

Ստեղծենք երկու օբյեկտ, որտեղ մեկը կհանդիսանա մյուսի պրոտոտիպը, և փորձենք այդ օբյեկտների հատկություններն արտածել _for in_ ցիկլի օգնությամբ, որպեսզի ամեն ինչ ավելի պարզ լինի։

```js
const fish = {
  canSwim: true,
};

const shark = {
  species: "great white",
  color: "white",
  __proto__: fish,
};
```

Այստեղ մենք ունենք _fish և shark_ օբյեկտները, ընդորում _shark_ օբյեկտի պրոտոտիպը հանդիսանում է _fish_ օբյեկտը, հետևաբար _shark_ օբյեկտը բացի իր «սեփական» հատկություններից, ունի նաև _fish_ օբյեկտից ժառանգած հատկություններ։ Այժմ գրենք պարզ **for in** ցիկլ, որն ընդամենը պետք է _alert_ անի _shark_ օբյեկտի հատկությունների անունները՝

```js
for (let key in shark) {
  alert(key);
}
```

Աշխատեցնելով կոդը, մենք կտեսնենք որ ցիկլն _alert_ կանի հատկությունների _species, color և canSwim_ անունները (_բանալիները_), որտեղից _species և color_ հատկությունների անունները _shark_ օբյեկտի «սեփականն» են, իսկ _canSwim_ հատկության անունը նա ժառանգել է _fish_ օբյեկտից, և _for in_ ցիկլի համար նույնպես տեսանելի է։

Իսկ ի՞նչ անել, եթե մենք ցանկանում ենք գործ անել օբյեկտի միայն «սեփական» հատկությունների հետ։ Մենք կարող ենք ցիկլի մեջ լրացուցիչ ստուգում դնել hasOwnProperty մեթոդի օգնությամբ։ Վերևի օրինակի վրա այն կլինի հետևյալ ձևով՝

```js
for (let key in shark) {
  if (shark.hasOwnProperty(key)) {
    alert(key);
  }
}
```

hasOwnProperty մեթոդի մասին առավել մանրամասն կարող եք նայել [այս հղումով։](./Best%20Practices%20for%20Property%20Checking%20in%20JavaScript.hy.md)

Այժմ եթե աշխատեցնենք կոդը, ապա կտեսնենք, որ _alert_ է լինում _shark_ օբյեկտի միայն «սեփական» հատկությունների անունները՝ _species և color_։

Արդեն գիտենք թե ինչպես **for in** ցիկլով ստանալ օբյեկտների հատկությունների անունները։ Այժմ տեսնենք թե ինչպես կարելի է ստանալ այդ հատկությունների արժեքները։

```js
for (let key in shark) {
  alert(shark[key]);
}
```

Աշխատեցնելով այս կոդը կտեսնենք, որ _alert_-ը արտածում է _shark_ օբյեկտի «սեփական» հատկությունների արժեքներ հանդիսացող _"great white"_-ը և _"white"_-ը, ինչպես նաև _fish_ օբյեկտից ժառանգված _true_ Բուլյան արժեքը։

Զանգվածների իտերացիայի համար **for in** ցիկլը նույնպես հնարավոր է օգտագործել, բայց խորհուրդ չի տրվում: Նախ **for in** ցիկլը չի երաշխավորում զանգվածի էլեմենտների ճիշտ հերթականությամբ արտածումը, ապա նաև այն օպտիմալացման ենթարկվում է միայն օբյեկտների հետ աշխատելու ժամանակ, զանգվածների պարագայում ինտերպրետատորի կողմից ոչ մի ներքին օպտիմալացում տեղի չի ունենում, և հետևաբար զանգվածների իտերացիան անհամեմատ դանդաղ է ընթանում։ Զանգվածների իտերացիայի համար միշտ ցանկալի է օգտագործել սովորական _for_ ու **ES6**-ում ավելացված _for of_ ցիկլերը, ինչպես նաև զանգվածների պրոտոտիպի _forEach_ մեթոդը։

**for in** ցիկլը կարելի է նաև օգտագործել օբյեկտների մակերեսային պատճենման (_shallow copy_) նպատակով։ Այն իհարկե մակերեսային պատճենման լավագույն տարբերակը չէ, կան ավելի ճշգրիտ, կարճ տարբերակներ, բայց իմանալ պետք է ընդհանուր պատկերացման համար։

```js
const shark = {
  species: "great white",
  color: "white",
};

const anotherShark = {};

for (let key in shark) {
  anotherShark[key] = shark[key];
}

console.log(shark === anotherShark); // false
```

Կոնսոլում՝ _shark_ և նրա մակերեսային պատճենը հանդիսացող _anotherShark_ օբյեկտների նույնականության ստուգումը վերադարձնում է _false_: Այսինքն նրանք իրարից արդեն բացարձակապես անկախ օբյեկտներն են։

**JavaScript** ծրագրավորման լեզվով ժամանակակից կոդ գրելիս հնարավորինս պետք է խուսափել ցիկլերի, այդ թվում նաև **for in** ցիկլի օգտագործումից։ Կարելի է օբյեկտների իտերացիայի համար օգտագործել _Object.keys(obj)_, _Object.values(obj)_ և _Object.entries(obj)_ մեթոդները, որոնք թույլ կտան գրել լակոնիկ և դրա հետ մեկտեղ պարզ ու ընթեռնելի դեկլարատիվ կոդ։ Բացի դրանից այս մեթոդները վերադարձնում են օբյեկտի` համապատասխանաբար հատկությունների անունների, հատկությունների արժեքների և հատկություննների անուն-արժեք զույգի զանգվածները, որոնց վրա արդեն հեշտությամբ կարելի է կանչել զանգվածի մի քանի տասնյակի հասնող մեթոդներն ու կատարել այն բոլոր մանիպուլյացիաները, որոնք մեզ անհրաժեշտ կլինեն։ Վերը թվարկված մեթոդներին ավելի մանրամասն կարող եք ծանոթանալ այստեղ՝

- [`Object.keys`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)
- [`Object.values`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Object/values)
- [`Object.entries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)
