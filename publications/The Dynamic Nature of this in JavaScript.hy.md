# this բանալի բառը JavaScript ծրագրավորման լեզվում: Օգտագործման առանձնահատկությունները՝ բացատրություններով: Ինչո՞վ է այն տարբերվում այլ օբյեկտ կողմնորոշված լեզուներում առկա նույնատիպ հասկացությունից:

**this** բանալի բառի վարքագիծը **JavaScript**-ում բավականին մեծ տարբերություններ ունի այլ ծրագրավորման լեզուներում՝ մասնավորապես _Java_-ում և _PHP_-ում նույնանման բանալի բառի դրսևորած վարքագծից։ Երևի նաև այս պատճառով է, որ այն դժվար է ընկալվում այլ ծրագրավորման լեզուներից հետո **JavaScript** սովորող ծրագրավորողների մոտ՝ պատճառ դառնալով դժգոհությունների, թե իբր այն տարօրինակ ձևով է աշխատում։

Իրականում ոչ մի տարօրինակություն գոյություն չունի, ուղղակի շատ ծրագրավորման լեզուներում ընդունված է, որ _this_-ը պետք է լինի ֆիքսված՝ այսինքն մեթոդը, որը ստեղծվել է օբյեկտի մեջ, որպես _this_-ի արժեք իր մեջ միշտ կրում է հղումը դեպի այն օբյեկտը, որի մեջ ստեղծվել է։ _JavaScript_-ում այդպես չէ, այստեղ _this_-ը ֆիքսված չէ, այն «ազատ» է, և ընդհանրապես կապ չունի թե մեթոդը որ օբյեկտի մեջ է ստեղծվել, կապ ունի միայն, թե որ օբյեկտն է տվյալ մեթոդը կանչում։

Բնականաբար խոսել այն մասին թե դա լավ է կամ վատ, իրականում անիմաստ է։ «Ազատ» _this_-ը համեմատած ֆիքսված _this_-ի հետ, ունի ինչպես մեծ առավելություններ, այնպես էլ մի շարք թերություններ։ Նախ դա մեզ հնարավորություն է տալիս ֆունկցիան բազմակի անգամ օգտագործել որպես մեթոդ՝ տարբեր օբյեկտների վրա, հետևաբար այն լեզվին տալիս է նաև բարձր ճկունություն՝ անհասանելի ծրագրավորման լեզուների մեծ մասի համար։ Մյուս կողմից չափազանց բարձր ճկունությունն իր հերթին մեծացնում է սխալներ անելու հավանականությունը։ Հետևաբար մեզ անհրաժեշտ է լավ պատկերացնել այն, որպեսզի կարողանանք օգտագործել բոլոր առավելությունները, որը մեզ տալիս է «ազատ» _this_-ի կոնցեպտը, և հնարավորինս խուսափել բոլոր այն խնդիրներից և վտանգներից, որն իր հետ բերում է լեզվի չափազանց բարձր ճկունությունը։

Մինչև առաջ անցնելը նախ փորձենք հասկանալ թե ինչ են իրենցից ներկայացնում ՄԵԹՈԴՆԵՐԸ։ Կան բազմաթիվ բնութագրումներ և ձևակերպումներ թե ինչ է մեթոդը։ Կարճ և կոնկրետ՝ _JavaScript_-ում մեթոդը ֆունկցիա է, որը պահվում է օբյեկտի մեջ։ Որպեսզի մենք օբյեկտի մեջ պահվող մեթոդին հասանելիություն ստանանք՝ կարող ենք օգտագործել կետ . օպերատորը։ Ու ընդհանրապես, ինչպես գիտենք, օբյեկտի հատկությանը կամ մեթոդին հասանելիություն ստանալու համար կա՛մ պետք է օգտագործենք կետ օպերատորը, կա՛մ էլ ինչպես ընդունված է ասել քառակուսի փակագծերը _[]_:

Այժմ ստեղծենք որևէ օբյեկտ, որն իր մեջ կունենա հատկություններ և մեթոդներ, ապա այդ օբյեկտի վրա փորձենք հասկանալ թե ինչ է _this_-ը։

```js
const person = {
  firstName: "John",
  lastName: "Smith",
  age: 25,
  func: function () {
    console.log(this);
  },
};
```

Ունենք սովորական օբյեկտ, որի մեջ կան հատկություններ, որոնք կրում են ինֆորմացիա _person_ օբյեկտի անվան, ազգանվան և տարիքի մասին։ Օբյեկտի մեջ կա նաև _func_ մեթոդը (_Ինչպես հիշում ենք JavaScript-ում մեթոդը օբյեկտի մեջ գտնվող ֆունկցիա է_), որի կանչը պետք է ընդամենը կոնսոլում տպի _this_-ի արժեքը։ Ինչպե՞ս կարող ենք դրսից կանչել այդ մեթոդը՝ պետք է գրենք այն օբյեկտի անունը, որի մեջ գտնվում է մեթոդը, ապա կետ օպերատորը, հետո մեթոդի անունը և վերջում փակագծերը, որոնք ինչպես գիտենք օգտագործվում են ֆունկցիաների/մեթոդների կանչի համար։

```js
person.func(); // {firstName: "John", lastName: "Smith", func: ƒ}
```

Եվ այսպես, կանչելով _person_ օբյեկտի _func_ մեթոդը, որը պետք է կոնսոլում ուղղակի տպեր _this_-ը, ստանում ենք նույն _person_ օբյեկտը։

Այժմ դիտարկենք ուրիշ օրինակ, որպեսզի ավելի լավ պատկերացնենք թե ինչ է _this_-ը։ Ստեղծենք ոչ թե մեթոդ, այլ սովորական ֆունկցիա, որը կանչի դեպքում պետք է կոնսոլում տպի _this_-ը։

```js
function foo() {
  console.log(this);
}
```

Եթե այժմ այս ֆունկցիան կանչենք՝ ապա կախված նրանից, թե մենք խիստ ռեժիմում ենք, թե ոչ, կստանանք տարբեր արդյունքներ։ Հիշեցնեմ թե ինչ է խիստ ռեժիմը։ Քանի-որ _JavaScript_-ը ստեղծվել էր անհավանական կարճ ժամկետում՝ _10_ օրից մինչև _2_ շաբաթ՝ ըստ տարբեր աղբյուրների, նրա մեջ շատ կային կառուցվածքային թերություններ, որոնք չափազանց դժվարացնում էին լեզվի օգտագործումը, և **ES5** ստանդարտում որոշեցին ավելացնել խիստ ռեժիմը, որտեղ այդ կառուցվածքային թերություններից շատերն ուղղված են, և կոդը որոշ դեպքերում կարող է այլ կերպ աշխատել։ Որպեսզի ապահովեն հետադարձ համատեղելիություն, և մինչ այդ գրված սքրիփթները «փուլ չգան», այդ ռեժիմը ակտիվ չէ։ Եթե ուզում ենք մեր գրած կոդը ենթարկվի խիստ ռեժիմի կանոններին, պետք է սքրիփթի սկզբնամասում գրվի **"use strict"** հրահանգը։ Հրահանգը գրել պետք չէ, եթե մենք օգտագործում ենք մոդուլներ կամ կլասսների սինթաքսը, այդ դեպքում այն ավտոմատ ակտիվանում է։ Խիստ ռեժիմի մասին մանրամասն կարդացեք [այստեղ։](./JavaScript%20Strict%20Mode%20Directive%20and%20Its%20Impact.hy.md)

Եվ այսպես փորձենք _foo_ ֆունկցիան կանչել սկզբից սովորական, իսկ հետո խիստ ռեժիմում և տեսնենք թե _this_-ը կախված ռեժիմից ինչ արժեքներ է ընդունում։

```js
foo(); // {window: Window, self: Window, …}
```

Բրաուզերի միջավայրում ֆունկցիայի կանչը կոնսոլում կտպի _Window_ գլոբալ օբյեկտը, _node.js_-ի միջավայրում՝ _Object[global]_ գլոբալ օբյեկտը։ Այսինքն սովորական ռեժիմում ինտերպրետատորը ֆունկցիաներին որպես _this_-ի սկզբնական արժեք, կապում է գլոբալ օբյեկտը։

```js
"use strict";
foo(); // undefined
```

Խիստ ռեժիմում այդպիսի սկզբնական վերագրում չի լինում, և ֆունկցիայի կանչը թե բրաուզերային, թե _node.js_-ի միջավայրերում վերադարձնում է undefined, այսինքն ֆունկցիայի this-ը որոշված չէ, գոյություն չունի։ Սա տրամաբանական է, քանի որ ֆունկցիան մենք չենք ստեղծել որևէ օբյեկտի մեջ, այն չի հանդիսանում որևէ օբյեկտի մեթոդ, հետևաբար նրա _this_-ն էլ անորոշ է, գոյություն չունի։

Այժմ ստեղծենք մեկ այլ ֆունկցիա, որը պետք է ուղղակի կոնսոլում տպի ողջույնի խոսք։ Անվանենք այն ասենք թե _greeting_:

```js
function greeting() {
  console.log("hello " + this.firstName);
}
```

Ինչպես տեսնում ենք այս ֆունկցիայի կանչը կոնսոլում պետք է տպի _"hello"_ ողջույնի խոսքը, ուղղված _this.firstName_-ին։ Բայց մենք տեսանք, որ ժամանակակից ռեժիմում՝ խիստ ռեժիմում, ֆունկցիայի _this_-ը անորոշ է, ֆունկցիան ոչ մի օբյեկտի մեջ ստեղծված չէ, հետևաբար նրա _this_-ը _undefined_ է։ Հիմա եթե ֆունկցիան կանչենք, կստանանք սխալ, քանի-որ ինտերպրետատորը փորձելու է _this_-ից կարդալ _firstName_ հատկությունը, իսկ քանզի _this_-ը դա _undefined_ է, կոնսոլում կստանանք **Uncaught TypeError**։

```js
greeting(); // Uncaught TypeError
```

Իսկ այժմ փորձենք այս ֆունկցիան կանչել մեր _person_ օբյեկտի կոնտեքստում։ Օբյեկտի մեջ ստեղծենք _sayHello_ մեթոդը, որին կվերագրենք մեր ստեղծած _greeting_ ֆունկցիան։

```js
const person = {
  firstName: "John",
  lastName: "Smith",
  age: 25,
  func: function () {
    console.log(this);
  },
  sayHello: greeting,
};
```

Այստեղ ոչ մի բարդ բան չենք արել։ Ուղղակի նույն _person_ օբյեկտի մեջ ավելացրել ենք _sayHello_ մեթոդը, որը հղվում է օբյեկտից դուրս ստեղծված _greeting_ ֆունկցիային։ Այսինքն երբ կանչում ենք _sayHello_ մեթոդը՝ դա նույնն է, թե մենք կանչում ենք _greeting_ ֆունկցիան, ուղղակի այդ կանչը կատարվում է օբյեկտի մեջից։

```js
person.sayHello(); // hello John
```

Ամեն ինչ տրամաբանական է՝ ինչպես ամենավերևում գտնվող օրինակի մեջ համոզվել էինք, _person_ օբյեկտի մեջ գտնվող մեթոդի համար որպես _this_ հանդես էր գալիս հենց _person_ օբյեկտը, հետևաբար _person_ օբյեկտի մեջից կանչելու դեպքում _"hello " + this.firstName_ արտահայտությունը համարժեք է _"hello " + person.firstName_ արտահայտությանը։

Ստեղծենք մեկ ուրիշ օբյեկտ, նման _person_ օբյեկտին, ասենք թե _person2_:

```js
const person2 = {
  firstName: "Joseph",
  lastName: "Biden",
  age: 78,
  sayHello: greeting,
};
```

_person2_ օբյեկտի մեջ նույնպես պարունակվում են հատկություններ, որոնք նկարագրում են օբյեկտի անունը, ազգանունը և տարիքը։ Կա նաև _sayHello_ մեթոդը, որը կրկին հղվում է _greeting_ ֆունկցիային։ Կետ օպերատորի օգնությամբ հասանելիություն ստանանք _person2_ օբյեկտի պարունակությանը, և կանչենք _sayHello_ մեթոդը։

```js
person2.sayHello(); // hello Joseph
```

Ինչպես տեսնում ենք թե՛ _person_ և թե՛ _person2_ օբյեկտների մեջ գտնվող _sayHello_ մեթոդը հղվում է նույն _greeting_ ֆունկցիային, սակայն կախված նրանից, թե որ օբյեկտի վրա ենք կանչում ֆունկցիան, _this_-ը հանդիսանում է հենց այդ օբյեկտը։

Եվ այստեղ ձևակերպենք _this_-ի ամենակարևոր կանոնը։ Երբ ֆունկցիան կանչվում է մեթոդի սինթաքսով՝ _object.method()_, կանչի ժամանակ _this_-ը ՄԻՇՏ հանդիսանում է ԿԵՏԻՑ առաջ եղած օբյեկտը։ Մենք կարող ենք ստեղծել տաս, հարյուր, հազար այդպիսի օբյեկտներ, և նրանց մեջ ներդնել մեթոդ, որը ինչպես _person_-ի և _person2_-ի դեպքում՝ հղում կունենա մի ֆունկցիայի, որի մարմնում օգտագործվում է _this_ բանալի բառը։ Այդ _this_-ը տարբեր օբյեկտների դեպքում կունենա տարբեր արժեքներ, այսինքն եթե կանչվել է _person_ օբյեկտի վրա, _this_-ը կլինի _person_ օբյեկտը, եթե կանչվել է _person2_ օբյեկտի վրա, ապա _this_-ը կհանդիսանա _person2_ օբյեկտը, եթե կանչվել է ինչ-որ ասենք թե _admin_ օբյեկտի վրա, _this_-ը կհանդիսանա _admin_ օբյեկտը և այդպես շարունակ։

Եթե հիմա ստեղծենք մեկ այլ օբյեկտ, ասենք թե _visitor_, և նրա մեջ լինի մեթոդ, որը կհղվի _greeting_ ֆունկցիային, որին իրենց հերթին հղում ունեն նաև _person_ և _person2_ օբյեկտների մեջ գտնվող մեթոդներ, կախված թե որ օբյեկտի կոնտեքստում է կանչվելու այդ ֆունկցիան, մենք որպես _this_-ի արժեք կունենաք տվյալ օբյեկտը։

```js
const visitor = {
  firstName: "George",
  lastName: "Washington",
  sayHello: greeting,
};
```

Հիմա եթե կանչենք _visitor_ օբյեկտի _sayHello_ մեթոդը, որը կրկին հղվում է _greeting_ ֆունկցիային, ապա ըստ _this_-ի ամենակարևոր կանոնի, որն է՝ կետից առաջ գրված օբյեկտը հանդիսանում է տվյալ ֆունկցիայի _this_-ը, մենք որպես _this_-ի արժեք կունենանք _visitor_ օբյեկտը։

```js
visitor.sayHello(); // hello George
```

Իսկ ի՞նչ կլինի, եթե մենք օբյեկտի մեթոդը վերագրենք մեկ ուրիշ փոփոխականի, և փորձենք մեթոդը կանչել այդ փոփոխականի օգնությամբ։ Օրինակ _person2_-ի _sayHello_ մեթոդը վերագրենք ասենք թե ինչ-որ _func_ փոփոխականի։

```js
const func = person2.sayHello;
```

Հիմա _func_ փոփոխականի մեջ մենք պատճենել ենք _person2_ օբյեկտի _sayHello_ մեթոդը։ Ավելի ճիշտ՝ քանի-որ ֆունկցիաները նույնպես հանդիսանում են օբյեկտներ, այսինքն հղումային տիպ են, _func_ փոփոխականի մեջ մենք հիմա ունենք ոչ թե հենց _person2_ օբյեկտի _sayHello_ մեթոդը ուղղակիորեն՝ այլ հղումը դեպի նա։ Փորձենք կանչել _func_ ֆունկցիան՝

```js
func(); // Uncaught TypeError
```

Մենք ստանում ենք տիպային սխալ։ Բայց չէ՞ որ _func_ փոփոխականը նույնպես հղվում է _person2_ օբյեկտի _sayHello_ մեթոդի վրա։ Այո՛, հղվում է, բայց մենք _func()_-կանչում ենք ուղղակիորեն, ֆունկցիայի կանչից առաջ չկա կետ, որից առաջ օբյեկտ, որն էլ հենց հանդիսանալու էր _this_-ը։ Մենք _func_-ը փաստացի որևէ օբյեկտի մեջից չենք կանչում, իսկ ինչպես արդեն գիտենք, եթե ֆունկցիան չի հանդիսանում մեթոդ, չի կապված որևէ օբյեկտի հետ, գլոբալ տարածության մեջ նրա կանչի դեպքում _this === undefined_, եթե իհարկե խիստ ռեժիմը ակտիվ է։ Իսկ փորձելով _undefined_ արժեքից կետ օպերատորի օգնությամբ հասանելիություն ստանալ _firstName_ հատկությանը, մենք բնականաբար կստանանք տիպային սխալ, քանի-որ _undefined_-ը օբյեկտ չէ, որ տրված հատկությունն ունենա կամ չունենա, այն պրիմիտիվ տիպ է։

Սա այն ամենակարևոր հիմքն է, որն անհրաժեշտ է իմանալ _this_ բանալի բառի մասին։ Մնացած ամեն ինչ հասկանալի կլինի, եթե հասկացվի այսքանը (_ֆունկցիայի call, apply և bind մեթոդները և այլն_)։ Ամփոփելով այս թեման, կարելի է շեշտել _this_-ի աշխատանքի հիմնական կարևոր առանձնահատկություններն ու կանոնները՝

**JavaScript**-ում _this_-ը տարբերվում է մի շարք այլ հանրաճանաչ ծրագրավորման լեզուների _this_-ի ցուցաբերած վարքագծից՝ նրա արժեքը որոշվում է միայն կոդի կատարման ժամանակ։ Այսինքն ցանկացած ֆունկցիա հայտարարելուց, մենք նրա մեջ կարող ենք օգտագործել _this_-ը։ Սակայն այդ _this_-ը իմաստ չի ունենա այնքան ժամանակ, քանի դեռ մենք ֆունկցիան չենք կանչել ինչ-որ կոնտեքստում։

Երբ ֆունկցիայի կանչը տեղի է ունենում գլոբալ տարածության մեջ, ապա _this_-ի արժեքը լինում է անորոշ՝ _undefined_: Եթե կոդը գրելիս չի օգտագործվում ժամանակակից խիստ ռեժիմը, ապա _this_-ի արժեքը դառնում է գլոբալ օբյեկտը։

Երբ ֆունկցիան կանչվում է մեթոդի սինթաքսով՝ _object.method()_, ապա _this_-ը ՄԻՇՏ հանդիսանում է ԿԵՏ-ից առաջ գտնվող ՕԲՅԵԿՏԸ։
