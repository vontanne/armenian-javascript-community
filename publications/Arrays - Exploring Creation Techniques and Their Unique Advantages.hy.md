# Այս գրառման մեջ մենք կծանոթանանք, թե ինչպե՞ս ստեղծել զանգված՝ օգտագործելով ES6-ում ներդրված Array.of մեթոդը:

Ինչպես գիտենք **_JavaScript_**-ում զանգվածներ կարելի է հեշտությամբ ստեղծել երկու տարածված եղանակներով՝ _Array_ կոնստրուկտորի օգնությամբ կամ _լիտերալ սինթաքսի_ միջոցով։ Օրինակ ստեղծենք անունների զանգված՝ օգտվելով վերոհիշյալ եղանակներից։

```js
const nameList1 = new Array("John", "Joe", "Jane");
const nameList2 = ["Ann", "Cristy", "Margot"];
```

Երկրորդ տարբերակը՝ այսպես կոչված լիտերալ սինթաքսը, նախընտրելի է։ Այն ենթադրում է, որ ստեղծվելիք զանգվածի տարրերն ուղղակի ներառում ենք քառակուսի փակագծերի մեջ։ Իսկ նախընտրելի է առաջին հերթին այն պատճառով, որ կարճ ու պարզ է, և բացի դրանից ոչ մի թյուրիմացության պատճառ չի կարող հանդիսանալ, ի տարբերություն ինչպես հիմա կտեսնենք _Array_ կոնստրուկտորի։

_Array_ կոնստրուկտորի օգնությամբ զանգվածների ստեղծումն ունի թաքնված «ստորջրյա խութեր»։ Մասնավորապես, եթե մենք կոնստրուկտորին որպես արգումենտ հաղորդենք մեկ հատ ամբողջ թիվ, ապա մենք կստանանք ոչ այն, ինչ նախատեսել էինք։ Դիտարկենք հետևյալ օրինակը՝

```js
const numberList = new Array(7);
console.log(numberList); // [empty × 7]
```

Ինչպես տեսնում ենք կոնստրուկտորը ստեղծել է դատարկ զանգված՝ որի երկարությունը հավասար է 7-ի, այնինչ մենք ցանկանում էինք ստեղծել զանգված, որն իր մեջ կունենար 7 թվային արժեքը։ Այս տարօրինակ վարքագիծը դրսևորվում է միայն այն դեպքում, երբ արգումենտը մի հատ է, և իրենից ներկայացնում է ամբողջ թիվ։ Եթե որպես արգումենտ տանք երկու կամ ավել ամբողջ թվեր, ամեն ինչ կլինի սովորականի նման․

```js
const numberList2 = new Array(7, 8);
console.log(numberList2); // [7, 8];
```

_Array_ կոնստրուկտորի այս վարքագիծը կարող է սխալների պատճառ դառնալ, որովհետև երբեմն կոնստրուկտորին հաղորդվող արգումենտները նախապես հայտնի չեն, և ծրագրի աշխատանքի ընթացքում են առաջանում, օրինակ կարող են մուտքագրվել ծրագիրն օգտագործողի կողմից։ **ES6** ստանդարտում ավելացված **_Array.of_** մեթոդը հեշտությամբ լուծում է այս խնդիրը։ Այժմ եթե մենք մեթոդին որպես արգումենտ տանք մեկ հատ ամբողջ թիվ, այն կաշխատի այնպես, ինչպես նախատեսվում էր։

```js
const numbers = Array.of(3);
console.log(numbers.length); // 1
console.log(numbers); //[3]
```

Արգումենտները կարող են լինել թվային, տեքստային և այլ տիպերի, այդ թվում նաև _null_ կամ _undefined_: Դիտարկենք ևս մեկ օրինակ՝ այս անգամ զանգվածի էլեմենտների տեքստային տիպին պատկանելիությամբ։

```js
const chars = Array.of("A", "B", "C");
console.log(chars.length); // 3
console.log(chars); // [ "A", "B", "C" ]
```

Ապահովության նկատառումներից ելնելով՝ կարելի է ընդհանրապես հրաժարվել Array կոնստրուկտորի կիրառությունից։ Լիտերալ սինթաքսը գործնականում լիովին բավարարում է առօրյա խնդիրների ճնշող մեծամասնության լուծման համար։ Իսկ սպեցիֆիկ դեպքերում կարելի է օգտագործել ES6 ստանդարտում ավելացված այս համեմատաբար նոր մեթոդը։ Բոլոր տեսակի ու տարիքի դիտարկիչների վրա մեթոդի անխափան աշխատանքն ապահովելու համար կարելի է օգտագործել պոլիֆիլ, օրինակ՝

```js
if (!Array.of) {
  Array.of = function () {
    return Array.prototype.slice.call(arguments);
  };
}
```
