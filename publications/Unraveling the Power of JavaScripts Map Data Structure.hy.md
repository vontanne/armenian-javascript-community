# Map տվյալների կառուցվածքը. Փորձենք համեմատել օբյեկտների հետ. Ի՞նչ առավելություններ և թերություններ ունի

**JavaScript**-ում կան տարբեր տվյալների կառուցվածքներ, և կախված ծրագրին ներկայացվող պահանջներից, ճիշտ կառուցվածք ընտրելը կարող է զգալիորեն բարելավել ծրագրի աշխատանքն ու բարձրացնել կոդի ընթեռնելիությունը։ Այսօր կխոսենք մի շատ օգտակար տվյալների կառուցվածքի՝ **Map**-ի մասին։ **Map**-ի տարբեր ռեալիզացիաներ այսպես թե այնպես կան բոլոր հանրաճանաչ ծրագրավորման լեզուներում, թեև կարող են ուրիշ անուններով կոչվել։ **JavaScript**-ում **Map**-ը ներդրվել է _2015_ թվականին ընդունված ստանդարտով **(ES6 կամ ECMAScript 2015)**, նաև հենց այդ ստանդարտով կատարվեցին ահռելի քանակով նորամուծություններ, որոնք **JavaScript**-ը դարձրեցին լուրջ, հասուն ու շատ հարմարավետ լեզու։

**Map**-ը դա տվյալների կառուցվածք է, որը բաղկացած է բանալի-արժեք _(key - value)_ զույգից, ինչպես հասարակ օբյեկտները, սակայն որպես բանալի կարող է հանդիսանալ տվյալների ցանկացած տիպ, ի տարբերություն օբեկտների, որտեղ բանալին կարող է լինել միայն _String_ և _Symbol_ տիպի։ **Map**-ը ունի նմանություններ նաև Զանգվածի հետ, մասնավորապես այն նույնպես տվյալների կարգավորված հավաքածու է, և _size_ հատկության օգնությամբ մենք կարող ենք իմանալ թե քանի էլեմենտ է այն պարունակում։
**Map** կարող ենք ստեղծել _new Map()_ սինթաքսի օգնությամբ՝

```js
const map = new Map();
```

Արդյունքում ստեղծվում է դատարկ **Map**: Արժեքները **Map**-ի մեջ ավելացնում ենք _map.set(key, value)_ մեթոդի օգնությամբ։ Առաջին արգումենտը միշտ դառնում է բանալի, երկրորդը` արժեք։ Օրինակ՝

```js
map.set("firstName", "Anakin");
map.set("lastName", "Skywalker");
map.set("occupation", "Jedi Knight");
```

**Map**-ը օգտագործում է _key => value_ սինթաքսը, իր մեջ գտնվող էլեմենտի բանալի-արժեք կապը ցույց տալու համար։ Օրինակ եթե վերևի օրինակը տպենք կոնսոլում, այն կունենա հետևյալ տեսքը։

```js
{"firstName" => "Anakin",
"lastName" => "Skywalker",
"occupation" => "Jedi Knight"};
```

Օրինակում մենք որպես բանալի օգտագործեցինք սովորական տող, ինչպես որ օբյեկտներում է։ Օբյեկտները բացի _String_ տիպից, սկսած **ES6** ստանդարտից թույլ են տալիս որպես բանալի օգտագործել նաև _Symbol_ և վերջ։ Այսինքն եթե մենք օբյեկտի մեջ փորձենք օգտագործել ցանկացած ուրիշ տիպի պատկանող բանալի, ապա այն անուղղակիորեն կվերափոխվի _String_-ի։ Օրինակ բերեք փորձենք օբյեկտում որպես բանալի օգտագործել հենց օբյեկտ։

```js
// ստեղծենք որևէ օբյեկտ
const objAsKey = { foo: "bar" };

// օգտագործենք այդ օբյեկտը որպես բանալի
// ուրիշ օբյեկտի համար
const obj = {
  [objAsKey]: "What will happen?",
};
```

եթե հիմա վերևի օրինակը տպենք կոնսոլում,կստանանք․

```js
{'[object Object]': "What will happen?"};
```

Քանի որ օբյեկտի բանալին կարող է լինել միայն _String_ և _Symbol_ տիպի, ինտերպրետատորը կատարել է օբյեկտի անուղղակի վերափոխում _String_-ի և ստացել է _[object Object]_։ Ինչ է սա նշանակում։ Եթե հիմա մենք ստեղծենք ևս մի օբյեկտ, և նույնպես փորձենք ավելացնել obj-ի մեջ որպես բանալի, այն նույնպես կվերափոխվի _[object Object]_-ի, և մենք նախորդ արժեքը կկորցնենք։

```js
const anotherObjAsKey = { baz: "bar" };
obj[anotherObjAsKey] = "oops";
console.log(obj); // {'[object Object]': "oops"};
```

**Map**-ը լուծում է այս պրոբլեմը, նրա մեջ որպես բանալի կարող ենք օգտագործել ինչ ուզեք` օբյեկտ, զանգված, բուլյան արժեքներ, անգամ _NaN_:

```js
// Ստեղծենք օբյեկտ
const objAsKey = { foo: "bar" };

// Ստեղծենք Map
const map = new Map();

// Map-ում որպես բանալի օգտագործենք օբյեկտը
map.set(objAsKey, "What will happen?");
```

Եթե այն հիմա տպենք կոնսոլում, ապա կտեսնենք որ մեր բանալին ոչ մի _[object Object]_- ի էլ չի վերածվել, ոչ մի վերափոխում չի կատարվել։

Բացի _map.set(key, value)_ սինթաքսից մենք կարող ենք նաև հենց **Map**-ի ստեղծման պահին միանգամից նրան տալ բանալի-արժեք զույգը։ Դրա համար կարող ենք օգտագործել ցանկացած օբյեկտ, որը ենթակա է իտերացիայի։ Հիմնականում դրա համար կիրառելի են երկչափ զանգվածները։ Վերևի օրինակը կարող ենք գրել նաև այսպես՝

```js
const map = new Map([
  ["firstName", "Anakin"],
  ["lastName", "Skywalker"],
  ["occupation", "Jedi Knight"],
]);
```

Զանգվածի մեջ եղած զանգվածի առաջին էլեմենտը դառնում է բանալի, երկրորդը՝ տվյալ բանալու արժեքը։

Օբյեկտները իտերացիայի հիմնականում չեն ենթարկվում, թեև կան օբյեկտներ, որոնց վրա հնարավոր է ռեալիզացնել **[Symbol.iterator]** մեթոդը, և նրանց վրա արդեն կարելի է կանչել _for of_ ցիկլը։ Սակայն _Object.entries(obj)_ մեթոդը վերադարձնում է զանգվածների զանգված, ճիշտ նույն կառուցվածքով, որն անհրաժեշտ է **Map** ստեղծելուց կոնստրուկտորին որպես արգումենտ հաղորդելու համար։ Հետևաբար, եթե մենք ունենք օբյեկտ, որն ուզում ենք վերափոխել **Map**-ի, կարող ենք նախ _Object.entries(obj)_ սինթաքսը օգտագործելով ստանալ երկչափ զանգված, ապա այն որպես արգումենտ տալ _new Map()_ կոնստրուկտորին։ Օրինակ՝

```js
const anakin = {
  firstName: "Anakin",
  lastName: "Skywalker",
  occupation: "Jedi Knight",
};

const map = new Map(Object.entries(anakin));
```

Հակառակ գործողությունը՝ ստանալ օբյեկտ **Map**-ից, նույնպես շատ հեշտ է․

```js
const obj = Object.fromEntries(map);
```

**Map**-ից զանգված կարող ենք ստանալ օգտագործելով _Array.from(map)_ սինթաքսը։ Մեր օրինակում՝

```js
const arr = Array.from(map);
```

Ելքում կունենանք երկչափ զանգված՝

```js
[
  ["firstName", "Anakin"],
  ["lastName", "Skywalker"],
  ["occupation", "Jedi Knight"],
];
```

Ինչպես արդեն ասվեց, **Map**-ում կարող ենք ունենալ ցանկացած տիպի բանալի։ Օրինակ փորձենք թվերով՝

```js
map.set(1, "Number one");
```

Ի տարբերություն օբյեկտի, որտեղ 1-ը կվերափոխվեր _String "1"-ի_, այստեղ նման բան չի կատարվում:
Բանալի կարող է հանդիսանալ նաև բուլյան տիպի արժեքները, օրինակ՝

```js
map.set(true, "A Boolean");
```

Անգամ _Number_ տիպին պատկանող հատուկ արժեք _NaN_-ը՝

```js
const myMap = new Map();
myMap.set(NaN, "not a number");
```

Տպենք կոնսոլում, և կստանանք {NaN => "not a number"}

Երբ ուզում ենք իմանալ **Map**-ի մեջ կա արդյոք տվյալ բանալին, կարող ենք օգտագործել _map.has(key)_ մեթոդը, որը վերադարձնում է _true_, եթե **Map**-ի մեջ կա բանալին, հակառակ դեպքում՝ _false_: Օրինակ՝

```js
const map = new Map([
  ["animal", "cat"],
  ["shape", "triangle"],
  ["city", "Prague"],
  ["country", "Armenia"],
]);

map.has("firstName"); // false
map.has("country"); // true
```

Որպեսզի ստանանք արժեքներն ըստ բանալու, պետք է օգտագործենք _map.get(key)_ մեթոդը։

```js
map.get("animal"); // "cat"
```

**Map**-ի առավելություններից է հանդիսանում նաև այն, որ մենք ցանկացած պահի կարող ենք ստանալ նրա չափը՝ թե քանի էլեմենտ է պարունակում։ Դրա համար օգտագործում ենք _map.size_ հատկությունը։

```js
map.size; // 4
```

**Map**-ից որևէ էլեմենտ ջնջելու համար կարող ենք օգտագործել _delete_ մեթոդը։ Մեթոդը կվերադարձնի բուլյան արժեք, _true_ եթե գտել և ջնջել է տրված էլեմենտը, և _false_ եթե այդպիսի էլեմենտ չի կարողացել գտնել։

```js
// Ջնջենք էլեմենտը բանալու օգնությամբ
map.delete("shape"); // true
```

Եվ վերջապես մենք կարող ենք ջնջել **Map**-ի բոլոր էլեմենտները _clear_ մեթոդի օգնությամբ․

```js
// դատարկում է Map-ը
map.clear();
```

**Map**-ի էլեմենտները հերթով արտածելու համար գոյություն ունի 3 ներդրված մեթոդ։ Այդ մեթոդները վերադարձնում են **MapIterator** կոչվող իտերացվող օբյեկտ։

```js
const map = new Map([
  ["animal", "cat"],
  ["shape", "triangle"],
  ["city", "Prague"],
  ["country", "Armenia"],
]);
```

Առաջինը դիտարկենք _keys_ մեթոդը, այն վերադարձնում է **Map**-ի բոլոր բանալիները:

```js
map.keys(); // {"animal", "shape", "city", "country"}
```

Հաջորդը՝ _map.values_ մեթոդն է, վերադարձնում է բոլոր արժեքները.

```js
map.values(); // {"cat", "triangle", "Prague", "Armenia"}
```

Եվ վերջում՝ _map.entries()_ մեթոդը, որը վերադարձնում է բանալի-արժեք զույգերի իտերացվող օբյեկտ։ Այս տարբերակն է օգտագործում նաև _for of_ ցիկլը։

```js
map.entries(); // {"animal" => "cat", "shape" => "triangle", "city" => "Prague", "country" => "Armenia"}
```

**Map**-ն ունի նաև ներդրված _forEach_ մեթոդ, որը շատ նման է զանգվածի համանուն մեթոդին, ուղղակի հետադարձ կանչի _(callback)_ ֆունկցիային որպես պարամետր հանդիսանում են _value_-ն, _key_-ն և _map_-ը։ (_*Զանգվածի դեպքում՝ ընդունված է պարամետրերն անվանել item, index և array*_)

Ամփոփելով թեման կարող ենք նշել, որ թեև **Map**-ն իր կառուցվածքով նման է օբյեկտին, սակայն համեմատած ունի մի շարք առավելություններ։

- Map-ն ի տարբերություն օբյեկտի ունի ներդրված size մեթոդը, որը հնարավորություն է տալիս միանգամից ստանալ նրա չափը։
- Map-ն իտերացվող է, օբյեկտները՝ հիմնականում ոչ։
- Map-ը շատ ավելի ճկուն է, այստեղ մենք կարող ենք որպես բանալի օգտագործել ցանկացած տվյալի տիպ։
- Map-ի մեջ էլեմենտները երաշխավորված պահպանվում են ըստ ավելացման հերթականության։

Օբյեկտի մեջ թեև նույնպես հիմնականում այդպես է, բայց երաշխավորել դա չի կարելի։ Օրինակ այսպես կոչված **integer property**-ների առկայության դեպքում այդ հերթականությունը խախտվում է։

Իհարկե չի կարելի պնդել, որ **Map**-ը բոլոր առումներով գերազանցում է օբյեկտներին։ Իրականում օբյեկտները նույնպես շատ առավելություններ ունեն համեմատած **Map**-ի հետ։ Ամեն ինչ կախված է դիտարկվող խնդրի բնույթից։ Օրինակ օբյեկտները հրաշալի են աշխատում տվյալների ստանդարտ ձևաչափ հանդիսացող _JSON_-ի _JSON.parse()_ և _JSON.stringify()_ ֆունկցիաների հետ։ Բացի դրանից _օբյեկտի էլեմենտների հետ աշխատանքը շատ ավելի պարզ է՝ կետ օպերատորի գրելաձևը օգտագործելու շնորհիվ_։

Կապված արագագործության հետ՝ օբյեկտների հետ աշխատանքը հիմնականում ավելի արագ ու արդյունավետ է, որովհետև ցանցային դիտարկիչների engine-ները հիանալի օպտիմալացված են օբյեկտների և զանգվածների հետ աշխատելու համար։ Կան սիրողական թեսթերի արդյունքներ, որոնք ցույց են տալիս որ **Map**-ի հետ աշխատանքը անգամ ավելի արագ է, բայց դրանք այնքան էլ արժանահավատ չեմ համարում, և ավելի շուտ սպեցիֆիկ խնդիրների դեպքում է այդպես։ Ավելի լայն սպեկտրում օբյեկտները թեկուզ զուտ տեսականորեն պետք է, որ ավելի արագ աշխատեն, որովհետև բացի ցանցային դիտարկիչների engine-ների ամենաբարձր մակարդակով կազմակերպված օպտիմալացման, նրանք նաև շատ անգամ ավելի «թեթև» են։

Թեսթավորումն իրականում բավականին բարդ աշխատանք է, և հիմնարար գիտելիքներ ու փորձառություն է պահանջում։ Հիմնվելով սիրողական թեսթերի արդյունքների վրա չի կարելի պնդումներ անել։ Բայց ամեն դեպքում արագագործության այդ տարբերությունը փոքր է, և վճռորոշ դեր չի կարող խաղալ, և եթե **Map** օգտագործելով կարելի է ավելի ընթեռնելի, պարզ ու կարճ կոդ գրել, միանշանակ պետք է այն օգտագործել։
