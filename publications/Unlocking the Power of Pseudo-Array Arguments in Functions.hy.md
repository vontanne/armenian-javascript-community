# Այս գրառման մեջ մենք կանդրադառնանք ֆունկցիաների ներսում հասանելի arguments փսևդոզանգվածին: Որտե՞ղ է կարելի այն կիրառել, և ինչու՞ ժամանակակից կոդի մեջ այն ավելի ու ավելի հազվադեպ է օգտագործվում՝ փոխարինվելով rest parameter (...rest) սինթաքսով:

**JavaScript**-ում ֆունկցիաները կարող են կանչվել ցանկացած քանակությամբ արգումենտներով՝ անկախ նրանից, թե ֆունկցիայի հայտարարման ժամանակ մենք քանի պարամետր ենք սահմանել։ Օրինակ՝ ստեղծենք թվերի գումարման պարզագույն ֆունկցիա։

```js
function sum(a, b) {
  return a + b;
}

console.log(sum(2)); // NaN
console.log(sum(5, 3)); // 8
console.log(sum(4, 7, 9)); // 11
```

Ֆունկցիան ունի երկու պարամետր` _a և b_, կանչի ժամանակ այն վերադարձնում է դրանց գումարը։ Եթե մենք ֆունկցիան կանչենք մեկ արգումենտով՝ այդ արգումենտը կվերագրվի _a_-ին, իսկ _b_-ին անուղղակիորեն կվերագրվի _undefined_: հետևաբար ֆունկցիան կվերադարձնի _NaN_, քանի-որ փորձելով _undefined_ արժեքը անուղղակիորեն վերածել թվի, կստանա _NaN_, իսկ ինչպես հիշում ենք, _NaN_-ի հետ ցանկացած մաթեմատիկական գործողության արդյունքը միշտ կլինի _NaN_:

Երկրորդ օրինակը հասկանալի է, պետք է ստանար երկու արգումենտ, այդքան էլ ստացել է և վերադարձրել դրանց գումարը։ Երրորդ օրինակում մենք տալիս ենք երեք արգումենտ, թեև ֆունկցիան սահմանել ենք երկու պարամետրով, հետևաբար մեր տված երրորդ արգումենտն ուղղակի անտեսվում է։ Մենք կարող ենք ֆունկցիան կանչել թեկուզ _10_ արգումենտներով, ոչ մի սխալ չի լինի, ուղղակի բացի առաջինից և երկրորդից՝ մնացած բոլոր արգումենտներն անտեսվելու են։

Սակայն ֆունկցիայի մեջ հնարավոր է հասանելիություն ստանալ նրա կանչի ժամանակ հաղորդված բոլոր արգումենտներին։ Դրա համար **JavaScript**-ում գոյություն ունի հատուկ ներդրված օբյեկտ՝ **arguments**, որը նման է զանգվածի, բայց զանգված չէ, և իրենից ներկայացնում է բոլոր արգումենտների հավաքածուն։ Փաստացի _arguments_ փսևդոզանգվածը (փսևդո բառարմատը հունարենից թարգմանած նշանակում է կեղծ, այսինքն բառացիորեն՝ կեղծ զանգված, այդպիսի օբյեկտներին հաճախ անվանում են նաև զանգվածանման օբյեկտներ) դա լոկալ փոփոխական է, որը հասանելի է ֆունկցիայի մարմնի մեջ։ Ի դեպ այն գոյություն ունի բոլոր տեսակի ֆունկցիաների մեջ՝ անկախ ստեղծման եղանակից, բացի _arrow function_-ներից (_լյամբդա ֆունկցիաներ_):

Ինչու՞ է կոչվում փսևդոզանգված։ Որովհետև այն զանգված չէ, այլ սովորական օբյեկտ, ուղղակի նրա հատկությունների բանալիներն ամբողջ թվերի հեշտությամբ վերափոխվող, սակայն _String_ տիպին պատկանող արժեքներ են՝ սկսած _"0"_-ից, ապա _"1", "2", ․․․ "n"_ (_անգլերեն կոչվում են integer key-եր_): Փսևդոզանգվածները նաև ունեն _length_ հատկություն, որը ցույց է տալիս այդ զանգվածանման օբյեկտների հատկությունների քանակը։ Սակայն նրա վրա մենք չենք կարող օգտագործել զանգվածի մեթոդները՝ օրինակ _push_, _map_ կամ ասենք _reduce_: Ստեղծենք որևէ ֆունկցիա, որը կարտածի այդ փսևդոզանգվածի առանձին էլեմենտները, որպեսզի ամեն ինչ ավելի պարզ լինի։

```js
function foo() {
  console.log(arguments.length);
  console.log(arguments[0]);
  console.log(arguments[1]);
  console.log(arguments[2]);
}

foo(3, 5);
```

Կանչելով ֆունկցիան երկու արգումենտներով, մենք կտեսնենք, որ կոնսոլում համապատասխանաբար տպվում է _argumnets.length_-ը՝ _2_, _arguments[0]_-ն՝ _3_, և _arguments[1]_-ը՝ _5_։ Իսկ _arguments[2]_-ը _undefined_ է, քանի-որ մենք երրորդ արգումենտ չենք հաղորդել, և նրան անուղղակիորեն վերագրվում է անորոշ արժեք՝ _undefined_։

**JavaScript**-ում կան մի շարք ներդրված մեթոդներ՝ օրինակ _Math․max_-ը, որը կարող է ստանալ ցանկացած քանակությամբ արգումենտներ։ Մենք նույնպես կարող ենք ստեղծել ֆունկցիաներ, որոնք կստանան կամայական քանակությամբ արգումենտներ և նրանց հետ ինչ-որ գործողություն կկատարեն։ Օրինակ ստեղծենք պարզագույն ֆունկցիա, որը կստանա կամայական քանակի արգումենտներ և կվերադարձնի նրանց գումարը։ Նախկինում սա հնարավոր էր անել միայն _arguments_ փսևդոզանգվածի օգնությամբ, այժմ կա ավելի ժամանակակից եղանակ, որին նույնպես կանդրադառնամ։ Ֆունկցիան ստեղծենք այդ ժամանակների «ոգուն» համապատասխան՝ փոփոխականների հայտարարման համար օգտագործելով _var_ բանալի բառը, իսկ փսևդոզանգվածի իտերացիայի համար՝ սովորական _for_ ցիկլը, թեև ավելի հարմար կլիներ _for of_-ը։

```js
function sumOfArgs() {
  var sum = 0;
  for (var i = 0; i < arguments.length; i++) {
    sum += arguments[i];
  }
  return sum;
}

console.log(sumOfArgs(2, 3)); // Output: 5
console.log(sumOfArgs(2, 3, 5)); // Output: 10
```

Նաև նախկինում որպեսզի _arguments_ փսևդոզանգվածի հետ հնարավոր լիներ աշխատել զանգվածի ներդրված մեթոդներով՝ օրինակ _map_-ով, ստիպված էին օգտագործել ֆունկցիաների _call_ մեթոդը, կամ էլ այլընտրանքը՝ ցիկլի օգնությամբ պտտվելով _arguments_ փսևդոզանգվածի վրա՝ յուրաքանչյուր էլեմենտի հետ կատարել նախատեսված փոփոխությունը և ավելացնել նախապես ստեղծված դատարկ զանգվածի մեջ։

Ժամանակակից կոդի մեջ գնալով ավելի հազվադեպ է օգտագործվում _arguments_ ներդրված փսևդոզանգվածը, քանի-որ գոյություն ունի շատ անգամ ավելի հարմար _rest parameter_-ի սինթաքսը։ Այն ստեղծվում է ․․․ օպերատորի օգնությամբ (_ինչպես հայերենի կախման կետերի կետադրական նշանը_), և ֆունկցիայի ստեղծման ժամանակ կարող է իր մեջ «հավաքել» կամայական քանակի արգումենտներն ու ֆունկցիայի մարմնում տալ դրանց հասանելիություն։ Ընդ որում փոփոխականը, որն իր մեջ պարունակում է այդ արգումենտները՝ զանգված է, հետևաբար ի տարբերություն _arguments_ փսևդոզանգվածի՝ առանց լրացուցիչ ջանքերի կարելի է զանգվածի տասնյակ մեթոդներ կիրառելով կատարել բոլոր այն մանիպուլյացիաները, որոնք մեզ անհրաժեշտ են։ Օրինակ նույն այն պարզագույն ֆունկցիան, որը ստանում էր կամայական քանակի թվային արժեքով արգումենտներ և վերադարձնում դրանց գումարը, _rest parameter_ սինթաքսի օգնությամբ կարող է ունենալ հետևյալ տեսքը՝

```js
function sumOfArgs(...rest) {
  return rest.reduce((acc, elem) => acc + elem, 0);
}

console.log(sumOfArgs(2, 3)); // Output: 5
console.log(sumOfArgs(5, 10, 15)); // Output: 30
console.log(sumOfArgs(7, 8, 5, 6, 9)); // Output: 35
```

_rest_-ն ուղղակի պարամետրի անունն է, այդպես ընդունված է անվանել, բայց բնականաբար ոչ մի պարտադրանք չկա՝ կարելի է անվանել _args_ կամ ցանկացած այլ անունով, եթե իհարկե ռեզերվ արած բառ չէ։ Կա միայն մի պարտադրանք՝ _rest_ պարամետրը միշտ պետք է լինի վերջում, այն իր մեջ հավաքում է մնացյալ արգումենտները, և անիմաստ է նրանից հետո որևէ այլ պարամետր սահմանել։ Սակայն նրանից առաջ այլ պարամետրեր կարող են լինել։
